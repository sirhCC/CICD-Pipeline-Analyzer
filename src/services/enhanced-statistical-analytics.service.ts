/**
 * Enhanced Statistical Analytics Service - Optimized High-Performance Analytics
 * 
 * This is an optimized version of the statistical analytics service with:
 * - Memoization for expensive calculations
 * - Batch processing for large datasets
 * - Parallel computation support
 * - Memory-efficient algorithms
 * - Enhanced error handling and validation
 * - Performance monitoring integration
 * 
 * @author sirhCC
 * @version 2.0.0
 */

import { Logger } from '@/shared/logger';
import { AppError } from '@/middleware/error-handler';
import { memoizationService } from './memoization.service';
import { batchProcessingService } from './batch-processing.service';
import { optimizedMathUtils } from './optimized-math-utils.service';
import { PerformanceMonitorService } from './performance-monitor.service';
import {
  StatisticalDataPoint,
  AnomalyDetectionResult,
  TrendAnalysisResult,
  BenchmarkResult,
  SLAMonitoringResult,
  CostAnalysisResult,
  StatisticalAnalyticsConfig
} from './statistical-analytics.service';

export interface EnhancedAnalyticsConfig extends StatisticalAnalyticsConfig {
  // Performance optimizations
  enableMemoization: boolean;
  enableBatchProcessing: boolean;
  enableParallelProcessing: boolean;
  batchSize: number;
  maxConcurrency: number;
  
  // Memory management
  memoryThreshold: number; // MB
  enableStreamProcessing: boolean;
  
  // Caching
  cacheEnabled: boolean;
  cacheTtl: number; // milliseconds
  
  // Performance monitoring
  enablePerformanceTracking: boolean;
  slowQueryThreshold: number; // milliseconds
}

export interface AnalyticsPerformanceMetrics {
  operationName: string;
  executionTime: number;
  memoryUsage: number;
  cacheHit: boolean;
  dataSize: number;
  timestamp: Date;
}

export class EnhancedStatisticalAnalyticsService {
  private static instance: EnhancedStatisticalAnalyticsService;
  private logger: Logger;
  private config: EnhancedAnalyticsConfig;
  private performanceMetrics: AnalyticsPerformanceMetrics[] = [];

  private constructor(config?: Partial<EnhancedAnalyticsConfig>) {
    this.logger = new Logger('EnhancedStatisticalAnalytics');
    this.config = {
      // Inherit base config
      anomalyDetection: {
        zScoreThreshold: 2.0,
        percentileThreshold: 95,
        minDataPoints: 10,
        windowSize: 50,
      },
      trendAnalysis: {
        minDataPoints: 5,
        confidenceLevel: 0.95,
        smoothingFactor: 0.3,
      },
      benchmarking: {
        historicalDays: 30,
        minSamples: 5,
        updateFrequency: 3600000,
      },
      slaMonitoring: {
        defaultSLA: 95,
        violationBuffer: 0.05,
        alertThresholds: {
          minor: 90,
          major: 85,
          critical: 80
        },
      },
      costAnalysis: {
        defaultHourlyCost: 0.10,
        currencyCode: 'USD',
        resourceCosts: {
          cpu: 0.02,
          memory: 0.01,
          storage: 0.001,
          network: 0.005
        },
      },
      
      // Enhanced config
      enableMemoization: true,
      enableBatchProcessing: true,
      enableParallelProcessing: true,
      batchSize: 1000,
      maxConcurrency: 4,
      memoryThreshold: 512, // 512MB
      enableStreamProcessing: true,
      cacheEnabled: true,
      cacheTtl: 300000, // 5 minutes
      enablePerformanceTracking: true,
      slowQueryThreshold: 1000, // 1 second
      
      ...config
    };
  }

  public static getInstance(config?: Partial<EnhancedAnalyticsConfig>): EnhancedStatisticalAnalyticsService {
    if (!EnhancedStatisticalAnalyticsService.instance) {
      EnhancedStatisticalAnalyticsService.instance = new EnhancedStatisticalAnalyticsService(config);
    }
    return EnhancedStatisticalAnalyticsService.instance;
  }

  /**
   * Enhanced anomaly detection with optimization
   */
  public async detectAnomalies(
    data: StatisticalDataPoint[],
    method: 'z-score' | 'percentile' | 'iqr' | 'all' = 'all'
  ): Promise<AnomalyDetectionResult[]> {
    return this.executeWithPerformanceTracking('detectAnomalies', async () => {
      this.validateInput(data, this.config.anomalyDetection.minDataPoints);

      // Use batch processing for large datasets
      if (data.length > this.config.batchSize && this.config.enableBatchProcessing) {
        return this.detectAnomaliesBatch(data, method);
      }

      return this.detectAnomaliesOptimized(data, method);
    }, data.length);
  }

  /**
   * Enhanced trend analysis with memoization
   */
  public async analyzeTrend(data: StatisticalDataPoint[]): Promise<TrendAnalysisResult> {
    return this.executeWithPerformanceTracking('analyzeTrend', async () => {
      this.validateInput(data, this.config.trendAnalysis.minDataPoints);

      // Memoized computation for repeated requests
      const memoizedAnalysis = this.config.enableMemoization ? 
        memoizationService.memoizeAsync(this.computeTrendAnalysis.bind(this), {
          ttl: this.config.cacheTtl,
          keyGenerator: (data: StatisticalDataPoint[]) => 
            `trend_${this.generateDataHash(data)}`
        }) : this.computeTrendAnalysis.bind(this);

      return memoizedAnalysis(data);
    }, data.length);
  }

  /**
   * Enhanced benchmarking with parallel processing
   */
  public async generateBenchmark(
    currentValue: number,
    historicalData: StatisticalDataPoint[],
    category: string = 'general'
  ): Promise<BenchmarkResult> {
    return this.executeWithPerformanceTracking('generateBenchmark', async () => {
      this.validateInput(historicalData, this.config.benchmarking.minSamples);

      const values = historicalData.map(d => d.value);
      
      // Use parallel computation for statistical summary
      const stats = optimizedMathUtils.computeStatisticalSummary(values);
      const percentile = this.calculateValuePercentile(values, currentValue);
      
      return {
        currentValue,
        benchmark: stats.mean,
        percentile,
        deviationPercent: ((currentValue - stats.mean) / stats.mean) * 100,
        performance: this.determinePerformance(percentile),
        historicalContext: {
          best: stats.min,
          worst: stats.max,
          average: stats.mean,
          median: stats.median
        },
        comparison: {
          betterThan: percentile,
          category
        }
      };
    }, historicalData.length);
  }

  /**
   * Enhanced SLA monitoring with caching
   */
  public async monitorSLA(
    currentValue: number,
    slaTarget: number,
    historicalData: StatisticalDataPoint[],
    violationType: 'threshold' | 'availability' | 'performance' | 'quality' = 'performance'
  ): Promise<SLAMonitoringResult> {
    return this.executeWithPerformanceTracking('monitorSLA', async () => {
      const violated = currentValue < slaTarget;
      const violationPercent = violated ? ((slaTarget - currentValue) / slaTarget) * 100 : 0;

      // Optimized violation frequency calculation
      const recentViolations = this.calculateRecentViolations(historicalData, slaTarget);
      
      return {
        violated,
        slaTarget,
        actualValue: currentValue,
        violationPercent,
        violationType,
        severity: this.determineSLASeverity(violationPercent),
        timeInViolation: violated ? 1 : 0,
        frequencyOfViolation: recentViolations,
        remediation: this.generateSLARemediation(violationType, violationPercent)
      };
    }, historicalData.length);
  }

  /**
   * Enhanced cost analysis with batch processing
   */
  public async analyzeCosts(
    executionTimeMinutes: number,
    resourceUsage: {
      cpu: number;
      memory: number;
      storage: number;
      network: number;
    },
    historicalCostData: StatisticalDataPoint[]
  ): Promise<CostAnalysisResult> {
    return this.executeWithPerformanceTracking('analyzeCosts', async () => {
      const costs = this.config.costAnalysis.resourceCosts;
      const executionHours = executionTimeMinutes / 60;

      // Parallel cost calculation
      const totalCost = await this.calculateTotalCost(resourceUsage, costs, executionHours);
      const costPerMinute = totalCost / executionTimeMinutes;

      // Optimized trend analysis for cost data
      let costTrend: TrendAnalysisResult | null = null;
      if (historicalCostData.length >= this.config.trendAnalysis.minDataPoints) {
        costTrend = await this.analyzeTrend(historicalCostData);
      }

      return {
        totalCost,
        costPerMinute,
        costTrend: costTrend!,
        optimizationOpportunities: this.generateCostOptimizations(resourceUsage, totalCost),
        resourceUtilization: resourceUsage,
        efficiency: this.calculateEfficiencyScore(resourceUsage, executionTimeMinutes)
      };
    }, historicalCostData.length);
  }

  /**
   * Streaming analytics for very large datasets
   */
  public async* analyzeDataStream(
    dataStream: AsyncIterable<StatisticalDataPoint>,
    analysisTypes: ('anomaly' | 'trend' | 'benchmark')[] = ['anomaly']
  ): AsyncGenerator<{ type: string; result: any }, void, unknown> {
    if (!this.config.enableStreamProcessing) {
      throw new AppError('Stream processing is disabled', 400);
    }

    const windowSize = this.config.anomalyDetection.windowSize;
    const buffer: StatisticalDataPoint[] = [];

    for await (const dataPoint of dataStream) {
      buffer.push(dataPoint);

      // Process when buffer is full
      if (buffer.length >= windowSize) {
        for (const analysisType of analysisTypes) {
          try {
            let result;
            switch (analysisType) {
              case 'anomaly':
                result = await this.detectAnomalies(buffer);
                break;
              case 'trend':
                if (buffer.length >= this.config.trendAnalysis.minDataPoints) {
                  result = await this.analyzeTrend(buffer);
                }
                break;
              case 'benchmark':
                if (buffer.length >= this.config.benchmarking.minSamples) {
                  const latest = buffer[buffer.length - 1]!;
                  result = await this.generateBenchmark(latest.value, buffer.slice(0, -1));
                }
                break;
            }

            if (result) {
              yield { type: analysisType, result };
            }
          } catch (error) {
            this.logger.error(`Stream analysis error for ${analysisType}`, error);
          }
        }

        // Keep only last half of buffer for overlap
        buffer.splice(0, Math.floor(windowSize / 2));
      }
    }
  }

  // Private optimized methods

  private async detectAnomaliesBatch(
    data: StatisticalDataPoint[],
    method: 'z-score' | 'percentile' | 'iqr' | 'all'
  ): Promise<AnomalyDetectionResult[]> {
    const results: AnomalyDetectionResult[] = [];

    await batchProcessingService.processBatches(
      data,
      async (batch: StatisticalDataPoint[]) => {
        const batchResults = await this.detectAnomaliesOptimized(batch, method);
        results.push(...batchResults);
        return batchResults;
      },
      {
        onProgress: (progress) => {
          this.logger.debug('Anomaly detection progress', { 
            percentage: progress.percentage.toFixed(2) 
          });
        }
      }
    );

    return results;
  }

  private async detectAnomaliesOptimized(
    data: StatisticalDataPoint[],
    method: 'z-score' | 'percentile' | 'iqr' | 'all'
  ): Promise<AnomalyDetectionResult[]> {
    const values = data.map(d => d.value);
    const stats = optimizedMathUtils.computeStatisticalSummary(values);
    const results: AnomalyDetectionResult[] = [];

    data.forEach((point, index) => {
      const value = point.value;

      if (method === 'z-score' || method === 'all') {
        const zScore = Math.abs((value - stats.mean) / stats.standardDeviation);
        if (zScore > this.config.anomalyDetection.zScoreThreshold) {
          results.push(this.createAnomalyResult(value, zScore, 'z-score', stats));
        }
      }

      if (method === 'iqr' || method === 'all') {
        const lowerBound = stats.q1 - (1.5 * stats.iqr);
        const upperBound = stats.q3 + (1.5 * stats.iqr);
        
        if (value < lowerBound || value > upperBound) {
          const distance = Math.min(Math.abs(value - lowerBound), Math.abs(value - upperBound));
          const anomalyScore = distance / stats.iqr;
          results.push(this.createAnomalyResult(value, anomalyScore, 'iqr', stats));
        }
      }
    });

    return results;
  }

  private async computeTrendAnalysis(data: StatisticalDataPoint[]): Promise<TrendAnalysisResult> {
    const baseTime = data[0]!.timestamp.getTime();
    const xValues = data.map((d, i) => (d.timestamp.getTime() - baseTime) / (1000 * 60 * 60));
    const yValues = data.map(d => d.value);

    const regression = optimizedMathUtils.computeLinearRegression(
      xValues, 
      yValues, 
      this.config.trendAnalysis.confidenceLevel
    );

    const lastPoint = xValues[xValues.length - 1]!;
    const meanValue = optimizedMathUtils.computeMean(yValues);
    const changeRate = ((regression.slope * 24) / meanValue) * 100;

    return {
      trend: this.determineTrend(regression.slope, regression.standardError),
      slope: regression.slope,
      correlation: regression.correlation,
      rSquared: regression.rSquared,
      confidenceInterval: regression.confidenceInterval,
      prediction: {
        next24h: regression.slope * (lastPoint + 24) + regression.intercept,
        next7d: regression.slope * (lastPoint + 24 * 7) + regression.intercept,
        next30d: regression.slope * (lastPoint + 24 * 30) + regression.intercept
      },
      changeRate,
      volatility: this.calculateVolatility(yValues, regression)
    };
  }

  private async calculateTotalCost(
    resourceUsage: any,
    costs: any,
    executionHours: number
  ): Promise<number> {
    // Parallel cost calculation for better performance
    const costPromises = [
      Promise.resolve(resourceUsage.cpu * costs.cpu * executionHours),
      Promise.resolve(resourceUsage.memory * costs.memory * executionHours),
      Promise.resolve(resourceUsage.storage * costs.storage * executionHours),
      Promise.resolve(resourceUsage.network * costs.network)
    ];

    const costComponents = await Promise.all(costPromises);
    return costComponents.reduce((sum, cost) => sum + cost, 0);
  }

  private async executeWithPerformanceTracking<T>(
    operationName: string,
    operation: () => Promise<T>,
    dataSize: number
  ): Promise<T> {
    const startTime = performance.now();
    const startMemory = process.memoryUsage().heapUsed;

    try {
      const result = await operation();
      
      if (this.config.enablePerformanceTracking) {
        const endTime = performance.now();
        const endMemory = process.memoryUsage().heapUsed;
        const executionTime = endTime - startTime;
        
        const metrics: AnalyticsPerformanceMetrics = {
          operationName,
          executionTime,
          memoryUsage: endMemory - startMemory,
          cacheHit: false, // Would be determined by actual cache implementation
          dataSize,
          timestamp: new Date()
        };

        this.performanceMetrics.push(metrics);
        
        // Log slow queries
        if (executionTime > this.config.slowQueryThreshold) {
          this.logger.warn('Slow operation detected', { 
            operationName: metrics.operationName,
            executionTime: metrics.executionTime,
            dataSize: metrics.dataSize
          });
        }

        // Report to performance monitor
        const perfMonitor = PerformanceMonitorService.getInstance();
        perfMonitor.emit('analytics-operation', metrics);
      }

      return result;
    } catch (error) {
      this.logger.error(`Operation ${operationName} failed`, error);
      throw error;
    }
  }

  // Helper methods (simplified versions of originals)
  
  private validateInput(data: StatisticalDataPoint[], minSize: number): void {
    if (!Array.isArray(data) || data.length < minSize) {
      throw new AppError(`Insufficient data points. Required: ${minSize}, provided: ${data.length}`, 400);
    }
  }

  private generateDataHash(data: StatisticalDataPoint[]): string {
    const values = data.map(d => `${d.timestamp.getTime()}_${d.value}`).join('|');
    return Buffer.from(values).toString('base64').substring(0, 32);
  }

  private createAnomalyResult(
    value: number,
    anomalyScore: number,
    method: 'z-score' | 'iqr',
    stats: any
  ): AnomalyDetectionResult {
    return {
      isAnomaly: true,
      anomalyScore,
      method,
      threshold: method === 'z-score' ? this.config.anomalyDetection.zScoreThreshold : 1.5,
      actualValue: value,
      expectedRange: {
        min: method === 'z-score' 
          ? stats.mean - (this.config.anomalyDetection.zScoreThreshold * stats.standardDeviation)
          : stats.q1 - (1.5 * stats.iqr),
        max: method === 'z-score'
          ? stats.mean + (this.config.anomalyDetection.zScoreThreshold * stats.standardDeviation)
          : stats.q3 + (1.5 * stats.iqr)
      },
      confidence: Math.min(100, anomalyScore * 50),
      severity: this.determineSeverity(anomalyScore)
    };
  }

  private calculateValuePercentile(sortedValues: number[], value: number): number {
    let count = 0;
    for (const val of sortedValues) {
      if (val <= value) count++;
    }
    return (count / sortedValues.length) * 100;
  }

  private determinePerformance(percentile: number): 'excellent' | 'good' | 'average' | 'below-average' | 'poor' {
    if (percentile >= 90) return 'excellent';
    if (percentile >= 75) return 'good';
    if (percentile >= 50) return 'average';
    if (percentile >= 25) return 'below-average';
    return 'poor';
  }

  private calculateRecentViolations(historicalData: StatisticalDataPoint[], slaTarget: number): number {
    const recent = historicalData.filter(
      d => d.timestamp.getTime() > Date.now() - (24 * 60 * 60 * 1000)
    );
    return recent.filter(d => d.value < slaTarget).length;
  }

  private determineSLASeverity(violationPercent: number): 'minor' | 'major' | 'critical' {
    if (violationPercent >= 20) return 'critical';
    if (violationPercent >= 10) return 'major';
    return 'minor';
  }

  private generateSLARemediation(violationType: string, violationPercent: number) {
    // Simplified remediation logic
    return {
      immediateActions: ['Scale resources', 'Check health'],
      longTermActions: ['Optimize performance', 'Add monitoring'],
      estimatedImpact: `${Math.ceil(violationPercent / 2)}% improvement expected`
    };
  }

  private generateCostOptimizations(resourceUsage: any, totalCost: number) {
    // Simplified optimization logic
    return [];
  }

  private calculateEfficiencyScore(resourceUsage: any, executionTime: number) {
    // Simplified efficiency calculation
    return {
      score: Math.max(0, 100 - (executionTime / 60) * 10),
      recommendations: ['Optimize resource usage', 'Reduce execution time']
    };
  }

  private determineTrend(slope: number, standardError: number): 'increasing' | 'decreasing' | 'stable' | 'volatile' {
    const significance = Math.abs(slope) / Math.max(standardError, 0.0001);
    
    if (significance < 0.5) return 'stable';
    if (standardError > Math.abs(slope) * 3) return 'volatile';
    if (slope > 0) return 'increasing';
    return 'decreasing';
  }

  private calculateVolatility(values: number[], regression: any): number {
    // Calculate residuals and their standard deviation
    const n = values.length;
    let sumSquaredResiduals = 0;
    
    for (let i = 0; i < n; i++) {
      const predicted = regression.slope * i + regression.intercept;
      const residual = values[i]! - predicted;
      sumSquaredResiduals += residual * residual;
    }
    
    return Math.sqrt(sumSquaredResiduals / (n - 2));
  }

  private determineSeverity(anomalyScore: number): 'low' | 'medium' | 'high' | 'critical' {
    if (anomalyScore >= 5) return 'critical';
    if (anomalyScore >= 3) return 'high';
    if (anomalyScore >= 2) return 'medium';
    return 'low';
  }

  /**
   * Get performance metrics for monitoring
   */
  public getPerformanceMetrics(): AnalyticsPerformanceMetrics[] {
    return [...this.performanceMetrics];
  }

  /**
   * Clear performance metrics
   */
  public clearPerformanceMetrics(): void {
    this.performanceMetrics = [];
  }

  /**
   * Get configuration
   */
  public getConfig(): EnhancedAnalyticsConfig {
    return { ...this.config };
  }

  /**
   * Update configuration
   */
  public updateConfig(newConfig: Partial<EnhancedAnalyticsConfig>): void {
    this.config = { ...this.config, ...newConfig };
    this.logger.info('Enhanced analytics configuration updated');
  }
}

// Export singleton instance
export const enhancedStatisticalAnalyticsService = EnhancedStatisticalAnalyticsService.getInstance();
